# -*- coding: utf-8 -*-
import argparse
#import path_helpers as ph
import platform
import re
import sys

import bz2
import json
from objdict import ObjDict

c_head="/* Generated by lsusb for rp2040 */"

def addslashes(s):
  return repr('"' + s)[2:-1].replace('"', '\\"')

def parse_usb_ids_list(data):
    cre_vendor = re.compile(r'^(?P<vendor_id>[a-fA-F0-9]+)\s+' r'(?P<vendor_name>.*)$')
    cre_product = re.compile(r'^\s+(?P<product_id>[a-fA-F0-9]+)\s+' r'(?P<product_name>.*)$')

    usb_ids = {}
    vendor_j = None

    for line_i in data.strip().splitlines():
        match_i = cre_vendor.match(line_i)
        if match_i:
            vendor_j = {'name': match_i.group('vendor_name')}
            usb_ids[match_i.group('vendor_id')] = vendor_j
            continue

        match_i = cre_product.match(line_i)
        if match_i and vendor_j is not None:
            products_j = vendor_j.get('products', {})
            products_j[match_i.group('product_id')] =\
                {'name': match_i.group('product_name')}
            vendor_j['products'] = products_j
            continue
    return usb_ids


def parse_usb_class_list(data):

    usb_ids    = {}

    classes    = []
    subclasses = []
    protocols  = []

    for line in data.strip().splitlines():

        usb_class = re.compile(r'^C\s(?P<class>[a-fA-F0-9]+)\s+' r'(?P<class_name>.*)$')
        match_c = usb_class.match(line)
        if match_c:
            classes.append({"class":match_c.group('class'), "name":match_c.group('class_name'), "subclass_idx":len(subclasses), "subclass_count":0})

        usb_subclass = re.compile(r'^\s(?P<subclass>[a-fA-F0-9]+)\s+' r'(?P<subclass_name>.*)$')
        match_s = usb_subclass.match(line)
        if match_s:
            subclasses.append({"subclass":match_s.group('subclass'), "name":match_s.group('subclass_name'), "proto_idx":len(protocols), "proto_count":0})
            classes[len(classes)-1]["subclass_count"] = classes[len(classes)-1]["subclass_count"] + 1
            #classes[len(classes)-1]["subclass_idx"] = len(subclasses) - classes[len(classes)-1]["subclass_count"]

        usb_protocol = re.compile(r'^\s\s(?P<protocol>[a-fA-F0-9]+)\s+' r'(?P<protocol_name>.*)$')
        match_p = usb_protocol.match(line)
        if match_p:
            protocols.append({"protocol":match_p.group('protocol'), "name":match_p.group('protocol_name')})
            subclasses[len(subclasses)-1]["proto_count"] = subclasses[len(subclasses)-1]["proto_count"] + 1

    usb_ids["classes"]    = classes
    usb_ids["subclasses"] = subclasses
    usb_ids["protocols"]  = protocols
    return usb_ids



def classes_protos_to_c( usb_ids=None, output_file="classes_protos.h" ):
    if usb_ids==None:
        return

    u_class_t = [c_head]
    u_subcl_t = [c_head]
    u_proto_t = [c_head]

    u_class_t.append("struct usb_class_t { uint8_t class_id; const char* name; uint8_t subclass_t_idx; uint8_t subclass_count; };\n\nconst usb_class_t usb_classes[] = \n{")
    u_subcl_t.append("struct usb_subclass_t { uint8_t subclass_id; const char* name; uint8_t proto_t_idx; uint8_t proto_count; };\n\nconst usb_subclass_t usb_subclasses[] = \n{")
    u_proto_t.append("struct usb_proto_t { uint8_t proto_id; const char* name; };\n\nconst usb_proto_t usb_protos[] = \n{")

    usb_items=ObjDict(usb_ids)

    for u_class in usb_items.classes:
        u_class_t.append("  {0x"+u_class["class"]+ ', "' + addslashes(u_class["name"]) + '", ' +str(u_class["subclass_idx"])+ ", "  +str(u_class["subclass_count"])+ "},")

    for u_subclass in usb_items.subclasses:
        u_subcl_t.append("  {0x"+u_subclass["subclass"]+ ', "' + addslashes(u_subclass["name"]) + '", ' +str(u_subclass["proto_idx"])+ ", "  +str(u_subclass["proto_count"])+ "},")

    for u_protocol in usb_items.protocols:
        u_proto_t.append("  {0x"+u_protocol["protocol"]+ ', "' + addslashes(u_protocol["name"]) + '"},')

    u_class_t.append( "};\n\n" )
    u_subcl_t.append( "};\n\n" )
    u_proto_t.append( "};\n\n" )

    with open(output_file, "w") as c_file:
        c_file.write("\n".join(u_class_t))
        c_file.write("\n".join(u_subcl_t))
        c_file.write("\n".join(u_proto_t))



def vid_pid_to_c( usb_ids=None, output_file="usg.ids.h" ):
    if usb_ids==None:
        return
    c_vid_list = [c_head]
    c_vid_list.append("struct vendor_id_t { uint16_t vendor_id; const char* name; uint16_t product_id_t_idx; size_t product_count; };\n\nconst vendor_id_t usb_vids[] = \n{")
    c_pid_list = [c_head]
    c_pid_list.append("struct product_id_t { uint16_t product_id; const char* name; };\n\nconst product_id_t usb_pids[] = \n{")
    vendor_idx  = 0
    product_idx = 0
    for vendor_id in usb_ids:
        vendor_data = ObjDict(usb_ids[vendor_id])
        products_count=0
        if hasattr(vendor_data, 'products'):
            products_count=len(vendor_data.products)
            for product_id in vendor_data.products:
                product_data = ObjDict( vendor_data.products[product_id] )
                c_pid_list.append( '  { 0x' + product_id + ', "' + addslashes(product_data.name) + '"' +"}," )
        c_vid_list.append( '  { 0x' + vendor_id + ', "' + addslashes(vendor_data.name) + '"' + ", " + str(product_idx) + ", "+ str(products_count) +"}," )
        product_idx=product_idx+products_count
        vendor_idx=vendor_idx+1

    c_vid_list.append( "};\n\n" )
    c_pid_list.append( "};\n\n" )

    with open(output_file, "w") as c_file:
        c_file.write("\n".join(c_vid_list))
        c_file.write("\n".join(c_pid_list))


def main():
    input_file="usb.org/usb.ids" # get a copy from http://www.linux-usb.org/usb.ids
    vid_pid_file="usb.org/lsusb.ids.h" # will be overwritten
    classes_proto_file="usb.org/lsusb.classes_protos.h" # will be overwritten

    with open(input_file, 'r', encoding='windows-1252') as input_:
        contents=input_.read()

    sections=contents.split("# List of")

    for section in sections:
        section_name=section.split("\n")[0]
        if section_name=='#':
            section_name=" Vendors, devices and interfaces"
            usb_ids = parse_usb_ids_list(section)
            vid_pid_to_c(usb_ids, vid_pid_file)
        if section_name==' known device classes, subclasses and protocols':
            usb_classes=parse_usb_class_list(section) # TODO: parse this
            classes_protos_to_c(usb_classes, classes_proto_file)




if __name__ == '__main__':
    main()




